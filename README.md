# -зачёт
Подмодули
Начнём с добавления существующего Git-репозитория, в качестве подмодуля репозитория, в котором мы работаем. Для добавления нового подмодуля используем команду git submodule add с URL проекта, который мы хотим начать отслеживать. По умолчанию подмодули добавляют подпроекты в директории, называемые так же, как и соответствующие репозитории
Если у нас несколько подмодулей, то и в этом файле у нас будет несколько записей. Важно заметить, что этот файл добавлен под управление Git так же, как и другие ваши файлы, например, ваш файл .gitignore. Этот файл можно получить или отправить на сервер вместе с остальными файлами проекта. Благодаря этому другие люди, которые клонируют наш проект, узнают откуда взять подмодули проекта.
Клонирование проекта с подмодулями
Далее мы рассмотрим клонирование проекта, содержащего подмодули. Когда мы клонируем такой проект, по умолчанию получаем директории, содержащие подмодули, но ни одного файла в них не будет.

$ git clone https://github.com/...
существует другой немного более простой вариант сделать тоже самое. Если мы передадим опцию --recursive команде git clone, то она автоматически инициализирует и обновит каждый подмодуль в этом репозитории.
$ git clone --recursive https://github.com/...

рассмотрим, как мы будем работать совместно с нашими коллегами над основным проектом и над подпроектом.
Получение изменений из вышестоящего репозитория
Простейший вариант использования подмодулей в проекте состоит в том, что мы просто получаем сам подпроект и хотим периодически получать обновления, но в своей копии проекта ничего не изменяем. Если мы хотитм проверить наличие изменений в подмодуле, мы можем перейти в его директорию, выполнить git fetch и затем git merge для обновления локальной версии из вышестоящего репозитория. Теперь если мы вернёмся в основной проект и выполним git diff --submodule, то сможем увидеть, что подмодуль обновился, и получим список новых коммитов. Если мы не хотим каждый раз при вызове git diff указывать опцию --submodule, то можем установить такой формат вывода по умолчанию, задав параметру diff.submodule значение “log”.

Работа с подмодулем
Мы используетм подмодули, потому что хотим работать над кодом подмодуля (или нескольких подмодулей) во время работы над кодом основного проекта. Иначе бы вы, скорее всего, предпочли использовать более простую систему управления зависимостями (такую как Maven или Rubygems).
Рассмотрим пример, в котором мы одновременно с изменениями в основном проекте внесём изменения в подмодуль, зафиксировав и опубликовав все эти изменения в одно и то же время.
До сих пор, когда мы выполняли команду git submodule update для извлечения изменений из репозитория подмодуля, Git получал изменения и обновлял файлы в поддиректории, но оставлял подрепозиторий в состоянии, называемом “отделённый HEAD” (“detached HEAD”). Это значит, что локальная рабочая ветка (такая, например, как “master”), отслеживающая изменения, отсутствует. Таким образом, любые вносимые нами изменения не будут нормально отслеживаться.
Для упрощения работы с подмодулями нам необходимо сделать две вещи. Нам нужно перейти в каждый подмодуль и переключиться на ветку, в которой будем в дальнейшем работать. Затем нам необходимо сообщить Git, что ему делать если мы внесли изменения, а затем командой git submodule update --remote получаете новые изменения из репозитория. Возможны два варианта — мы можем слить их в вашу локальную версию или попробовать перебазировать наши локальные наработки поверх новых изменений.
Первым делом, давайте перейдём в директорию нашего подмодуля и переключимся на нужную ветку.
$ git checkout stable
Switched to branch 'stable'
Попробуем воспользоваться опцией “merge” (“слияния”). Для того, чтобы задать её вручную, мы можем просто добавить опцию --merge в наш вызов команды update.
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
Если мы перейдём в директорию DbConnector, то увидим, что новые изменения уже слиты в нашу локальную ветку stable. Теперь посмотрим, что случится, когда мы внесём свои собственные локальные изменения в библиотеку, а кто-то другой в это же время отправит другие изменения в вышестоящий репозиторий.
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)
Теперь если мы обновим наш подмодуль, то сможем увидеть, что случится, когда мы сделали локальные изменения, а вышестоящий репозиторий также имеет изменения, которые мы должны объединить.
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
Если мы забудете указать опцию --rebase или --merge, то Git просто обновит ваш подмодуль, до состояния, что есть на сервере, и установит ваш проект в состояние отделённого HEAD.
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
Если мы не зафиксировали наши изменения в подмодуле и выполнили его обновление, то это приведёт к проблемам — Git извлечёт изменения из вышестоящего репозитория, но не затрёт несохранённые наработки в директории вашего подмодуля.
$ git submodule update --remote
remote: Counting objects: 4, done.




